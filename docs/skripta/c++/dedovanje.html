

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dedovanje &mdash; Programerski krožek na Gimnaziji Vič 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=34b5f6bb" />

  
      <script src="../../_static/documentation_options.js?v=ece9439e"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex" />
    <link rel="search" title="Search" href="../../search" />
    <link rel="next" title="Predloge (templates)" href="templates" />
    <link rel="prev" title="Objekti" href="objekti" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index" class="icon icon-home">
            Programerski krožek na Gimnaziji Vič
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../python">Python</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python-vaje">Python vaje</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../c%2B%2B">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="uvod">Uvod</a></li>
<li class="toctree-l2"><a class="reference internal" href="osnove">Osnove</a></li>
<li class="toctree-l2"><a class="reference internal" href="podatkovni_tipi">Podatkovni tipi</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum">Enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="funkcije">Funkcije</a></li>
<li class="toctree-l2"><a class="reference internal" href="pointers">Kazalci in reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="objekti">Objekti</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Dedovanje</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#osnove-dedovanja">Osnove dedovanja</a></li>
<li class="toctree-l3"><a class="reference internal" href="#konstruktorji-in-destruktorji">Konstruktorji in destruktorji</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slicing">Slicing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hiding">Hiding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polimorfizem-in-virtualne-funkcije">Polimorfizem in virtualne funkcije</a></li>
<li class="toctree-l3"><a class="reference internal" href="#konstruktorji-in-virtualni-destruktorji">Konstruktorji in virtualni destruktorji</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ciste-virtualne-funkcije-in-abstraktni-razredi">Čiste virtualne funkcije in abstraktni razredi</a></li>
<li class="toctree-l3"><a class="reference internal" href="#daljsi-primer-uporabe-risanje-oblik">Daljši primer uporabe - risanje oblik</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="templates">Predloge (templates)</a></li>
<li class="toctree-l2"><a class="reference internal" href="organizacija">Organizacija kode</a></li>
<li class="toctree-l2"><a class="reference internal" href="izjeme">Izjeme (exceptions)</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../c%2B%2B-vaje">C++ vaje</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sql">SQL</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../git">Git</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../opengl">OpenGL</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../razbijanje">Kriptografija</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autodoc/modules">Dokumentacija</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../lov-na-zaklad">Lov na zaklad</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index">Programerski krožek na Gimnaziji Vič</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../c%2B%2B">C++</a></li>
      <li class="breadcrumb-item active">Dedovanje</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/skripta/c++/dedovanje.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="dedovanje">
<h1>Dedovanje<a class="headerlink" href="#dedovanje" title="Link to this heading">¶</a></h1>
<p>Dedovanje je način, da novi tipi obdržijo (podedujejo) atribute in metode
drugih tipov. Poleg tega lahko dodajo novo obnašanje, ali spremenijo starega.
Slednji koncept se imenuje <em>overriding</em>, ki ga ne mešati z <a class="reference internal" href="funkcije#overloading"><span class="std std-ref">Overloading</span></a>.</p>
<section id="osnove-dedovanja">
<h2>Osnove dedovanja<a class="headerlink" href="#osnove-dedovanja" title="Link to this heading">¶</a></h2>
<p>Začnimo s preprostim primerom:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">peci</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Torta se pece.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RojstnodnevnaTorta</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">;</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st_sveck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Tukaj razred <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code> deduje od razreda <code class="docutils literal notranslate"><span class="pre">Torta</span></code>,
saj je rojstnodnevna torta posebna vrsta torte - relacija “je”
nakazuje, da je uporaba podrazreda primerna. Po drugi strani, rojstnodnevna
torta ima svečke, kjer relacija “ima” označuje da so svečke njen atribut (in ne
npr. da bi <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code> dedovala od svečke).</p>
<p>Sintaksa oblike  <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">B</span> <span class="pre">:</span> <span class="pre">public</span> <span class="pre">A</span></code> označuje dedovanje, pri čemer <code class="docutils literal notranslate"><span class="pre">B</span></code>
dobi vse atribute in metode, ki jih ima <code class="docutils literal notranslate"><span class="pre">A</span></code>. Beseda <code class="docutils literal notranslate"><span class="pre">public</span></code> označuje, da
atributi ohranijo enak nivo dostopa (npr. <code class="docutils literal notranslate"><span class="pre">public</span></code>, <code class="docutils literal notranslate"><span class="pre">private</span></code> ali
<code class="docutils literal notranslate"><span class="pre">protected</span></code>), kot so ga imeli v <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Pri dedovanju lahko <code class="docutils literal notranslate"><span class="pre">B</span></code> doda
novo obnašanje in nove podatke, tako kot smo do zgoraj naredili za rojstnodnevno
torto. Pravimo, da je <code class="docutils literal notranslate"><span class="pre">A</span></code> <em>podrazred</em> razreda <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> pa <em>nadrazred</em>
razreda <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Sedaj lahko uporabljamo v podrazredu tudi podedovane metode nadrazreda.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="w"> </span><span class="n">torta</span><span class="p">;</span>
<span class="w">    </span><span class="n">torta</span><span class="p">.</span><span class="n">peci</span><span class="p">();</span><span class="w">  </span><span class="c1">// podedovano od torte</span>
<span class="w">    </span><span class="n">torta</span><span class="p">.</span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="konstruktorji-in-destruktorji">
<h2>Konstruktorji in destruktorji<a class="headerlink" href="#konstruktorji-in-destruktorji" title="Link to this heading">¶</a></h2>
<p>Dodajmo v naše razrede še konstruktorje. Razred <code class="docutils literal notranslate"><span class="pre">Torta</span></code> naj ima maso, razred <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>
pa še ime slavljenca. Oglejmo si definiciji:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">masa_</span><span class="p">;</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Torta</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">masa</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">masa_</span><span class="p">(</span><span class="n">masa</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">peci</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Torta se pece.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RojstnodnevnaTorta</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">slavljenec_</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">;</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">slavljenec</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">masa</span><span class="p">)</span><span class="w"> </span><span class="o">:</span>
<span class="w">        </span><span class="n">Torta</span><span class="p">(</span><span class="n">masa</span><span class="p">),</span><span class="w"> </span><span class="n">slavljenec_</span><span class="p">(</span><span class="n">slavljenec</span><span class="p">),</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st_sveck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Razred <code class="docutils literal notranslate"><span class="pre">Torta</span></code> ima običajen konstruktor, razred <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>
pa mora v konstruktorju kot prvo stvar poklicati nek konstruktor razreda
<code class="docutils literal notranslate"><span class="pre">Torta</span></code>, ki mu v zgornjem primeru poda maso. To se je zgodilo tudi v prejšnjem
primeru, le da ni bilo eksplicitno napisano. Razred <code class="docutils literal notranslate"><span class="pre">Torta</span></code> je namreč imel
default konstruktor, ki ne sprejeme parametrov in se je samodejno poklical
pred klicem konstruktorja <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>. Če imamo verigo dedovanja
<code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">:</span> <span class="pre">C</span> <span class="pre">:</span> <span class="pre">B</span> <span class="pre">:</span> <span class="pre">A</span></code> se ob konstruiranje objekta <code class="docutils literal notranslate"><span class="pre">D</span></code> začne s klicem izbranega
konstruktorja <code class="docutils literal notranslate"><span class="pre">A</span></code>, nadaljuje z <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, konstruktor <code class="docutils literal notranslate"><span class="pre">D</span></code> pa se pokliče
zadnji, ko so vsi starši že narejeni. Med drugim to pomeni, da so podedovani deli
objekta že konstruirani in lahko npr. kličemo podedovane metode ali uporabljamo
podedovane atribute. V drugih jezikih se tak klic pogosto naredi z uporabo
<code class="docutils literal notranslate"><span class="pre">super</span></code> (npr. Python, Java).</p>
<p>Pri destruktorjih je zgodba podobna, a obrnjena okrog. Če na razredu tipa <code class="docutils literal notranslate"><span class="pre">D</span></code>
pokličemo destruktor, se po koncu avtomatsko pokličejo tudi konstruktorji
staršev, tako da so podedovani atributi od <code class="docutils literal notranslate"><span class="pre">A</span></code> uničeni zadnji.</p>
<p>Poglejmo si to še na primeru:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">A</span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">C</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">C</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">D</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">D</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">__func__</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;test konstruktorjev in destruktorjev:&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="n">d</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Makro <code class="docutils literal notranslate"><span class="pre">__func__</span></code> je poseben ukaz v C++, ki se tekom prevajanja razširi v ime funkcije, kjer
smo ga uporabili. Če poženemo zgornji program, se izpiše</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span> <span class="n">konstruktorjev</span> <span class="ow">in</span> <span class="n">destruktorjev</span><span class="p">:</span>
<span class="n">A</span>
<span class="n">B</span>
<span class="n">C</span>
<span class="n">D</span>
<span class="o">~</span><span class="n">D</span>
<span class="o">~</span><span class="n">C</span>
<span class="o">~</span><span class="n">B</span>
<span class="o">~</span><span class="n">A</span>
</pre></div>
</div>
<p>kar se sklada z zgornjo razlago. Prav tako vidimo, da so vsi klici
konstruktorjev ali destruktorjev staršev avtomatski
in jih prevajalnik sam zgenerira namesto nas.</p>
</section>
<section id="slicing">
<span id="id1"></span><h2>Slicing<a class="headerlink" href="#slicing" title="Link to this heading">¶</a></h2>
<p>Eno izmed osnovnih načel dedovanja je, da lahko spremenljivko bolj specifičnega
tipa shranimo kot manj specifičen tip. Z našim primerom od prej gre sklep tako:
ker je <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code> tudi <code class="docutils literal notranslate"><span class="pre">Torta</span></code>, lahko spremenljivko tipa
<code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code> shranimo v spremenljivko tipa <code class="docutils literal notranslate"><span class="pre">Torta</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">RojstnodnevnaTorta</span><span class="w"> </span><span class="n">rt</span><span class="p">(</span><span class="s">&quot;Janez&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.4</span><span class="p">);</span>
<span class="n">Torta</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">;</span>
</pre></div>
</div>
<p>Pri tem zgubimo vse informacije o tem, da je <code class="docutils literal notranslate"><span class="pre">t</span></code> kdaj bila
<code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code> in na spremenljivki <code class="docutils literal notranslate"><span class="pre">t</span></code> lahko kličemo le metode in
dostopamo do atributov, ki jih ima <code class="docutils literal notranslate"><span class="pre">Torta</span></code>. Ta proces se imenuje <em>slicing</em>
ali <em>object slicing</em>, saj od podobjekta odrežemo stran vse metode in atribute,
ki jih osnovni objekt nima. To je z vidika alokacije prostora smiselno, za
spremenljivko tipa <code class="docutils literal notranslate"><span class="pre">Torta</span></code> imamo rezervirano toliko prostora, kot ga
potrebujemo zanjo in dodatne informacije morajo preč.</p>
</section>
<section id="hiding">
<span id="id2"></span><h2>Hiding<a class="headerlink" href="#hiding" title="Link to this heading">¶</a></h2>
<p>Recimo, da sedaj spremenimo definicijo razreda <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>,
tako da odstranimo dodatne konstruktorje in dodamo lastno metodo <code class="docutils literal notranslate"><span class="pre">peci</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RojstnodnevnaTorta</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">;</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Torta</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st_sveck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">peci</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Pecem rojstnodnevno torto.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sedaj poglejmo, kaj se zgodi, ko pokličemo</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">RojstnodnevnaTorta</span><span class="w"> </span><span class="n">rt</span><span class="p">;</span>
<span class="n">Torta</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">;</span>
<span class="n">rt</span><span class="p">.</span><span class="n">peci</span><span class="p">();</span>
<span class="n">t</span><span class="p">.</span><span class="n">peci</span><span class="p">();</span>
</pre></div>
</div>
<p>Izpiše se <code class="docutils literal notranslate"><span class="pre">Pecem</span> <span class="pre">rojstnodnevno</span> <span class="pre">torto.</span></code>, čemur sledi še <code class="docutils literal notranslate"><span class="pre">Torta</span> <span class="pre">se</span> <span class="pre">pece.</span></code>.
To je zato, ker je <code class="docutils literal notranslate"><span class="pre">t</span></code> tipa <code class="docutils literal notranslate"><span class="pre">Torta</span></code>, <code class="docutils literal notranslate"><span class="pre">rt</span></code> pa tipa <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>
in metoda <code class="docutils literal notranslate"><span class="pre">peci</span></code> se na teh dveh razredih obnaša različno. v veliko programskih
jezikih, npr. v Javi, bi se obakrat izpisalo <code class="docutils literal notranslate"><span class="pre">Pecem</span> <span class="pre">rojstnodnevno</span> <span class="pre">torto.</span></code>,
saj bi jezik se vedno vedel, da se, kljub temu, da je <code class="docutils literal notranslate"><span class="pre">t</span></code> tipa <code class="docutils literal notranslate"><span class="pre">Torta</span></code>, v
njem skriva <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>. V C++ zaradi slicing-a temu ni tako.
Z zgornjim primerom smo dosegli le, da na objektu <code class="docutils literal notranslate"><span class="pre">rt</span></code> ne moremo več direktno
metode <code class="docutils literal notranslate"><span class="pre">peci</span></code> iz razreda <code class="docutils literal notranslate"><span class="pre">Torta</span></code>, saj jo je skrila enako imenovana metoda
<code class="docutils literal notranslate"><span class="pre">peci</span></code> iz razreda <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>.
Temu procesu se v angleščini reče <em>hiding</em>, saj metoda iz podrazreda
prepreči dedovanje (skrije) metode iz nadrazreda, ki imajo enako ime.
To bi se zgodilo tudi, če metoda
<code class="docutils literal notranslate"><span class="pre">peci</span></code> ne bi imela popolnoma enakih parametrov, kot metoda <code class="docutils literal notranslate"><span class="pre">peci</span></code> iz razreda
<code class="docutils literal notranslate"><span class="pre">Torta</span></code>. Primer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RojstnodnevnaTorta</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">;</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Torta</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st_sveck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">peci</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Pecem rojstnodnevno torto za &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;minut.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Tudi v tem primeru prek objekta <code class="docutils literal notranslate"><span class="pre">rt</span></code> ne bi morali poklicati <code class="docutils literal notranslate"><span class="pre">rt.peci()</span></code> brez
parametrov, saj se to sklicuje na skrito (in zato ne podedovano) metodo <code class="docutils literal notranslate"><span class="pre">peci</span></code>
iz razreda <code class="docutils literal notranslate"><span class="pre">Torta</span></code>.  Dobimo napako:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>torta.cpp: In function ‘int main()’:
torta.cpp:21:13: error: no matching function for call to ‘RojstnodnevnaTorta::peci()’
     rt.peci();
             ^
torta.cpp:15:10: note: candidate: ‘void RojstnodnevnaTorta::peci(int)’
     void peci(int m) { cout &lt;&lt; &quot;Pecem rojstnodnevno torto za &quot; &lt;&lt; m &lt;&lt; &quot;minut.&quot; &lt;&lt; endl; }
          ^~~~
torta.cpp:15:10: note:   candidate expects 1 argument, 0 provided
</pre></div>
</div>
<p>ki pove le, da smo metodo <code class="docutils literal notranslate"><span class="pre">peci</span></code> poklicali narobe. Prevajalnik <code class="docutils literal notranslate"><span class="pre">clang++</span></code> je
tukaj bolj uporabniku prijazen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>torta.cpp:21:8: error: too few arguments to function call, expected 1, have 0; did you mean &#39;Torta::peci&#39;?
    rt.peci();
       ^~~~
       Torta::peci
torta.cpp:6:10: note: &#39;Torta::peci&#39; declared here
    void peci() { cout &lt;&lt; &quot;Torta se pece.&quot; &lt;&lt; endl; }
         ^
1 error generated.
</pre></div>
</div>
<p>in namigne, da smo morda želeli poklicati metodo iz nadrazreda.
Če želimo poleg metod v podrazredu tudi metode z enakim
imenom iz osnovnega razreda, moramo njihovo dedovanje eksplicitno zahtevati.
To lahko storimo z ukazom <code class="docutils literal notranslate"><span class="pre">using</span></code>, kot v primeru spodaj.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RojstnodnevnaTorta</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Torta</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">;</span>
<span class="w">    </span><span class="n">RojstnodnevnaTorta</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Torta</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span><span class="w"> </span><span class="n">st_sveck</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">dodaj_svecke</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">st_sveck</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Torta</span><span class="o">::</span><span class="n">peci</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">peci</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Pecem rojstnodnevno torto za &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;minut.&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Sedaj imamo na voljo tako <code class="docutils literal notranslate"><span class="pre">rt.peci()</span></code> (eksplicitno podedovano iz razreda <code class="docutils literal notranslate"><span class="pre">Torta</span></code>) in <code class="docutils literal notranslate"><span class="pre">rt.peci(7)</span></code>
iz razreda <code class="docutils literal notranslate"><span class="pre">RojstnodnevnaTorta</span></code>.
Če bi imeli obe metodi isto ime, ki morali (pa tudi sedaj lahko) metodo iz
nadrazreda klicati z polno kvalificiranim imenom kot <code class="docutils literal notranslate"><span class="pre">rt.Torta::peci()</span></code>.
Zaenkrat sicer še ne vemo, kaj so virtualne
metode, toda princip skrivanja je zanje enak kot za običajne metode (kadar ne
pride v igro overriding).</p>
</section>
<section id="polimorfizem-in-virtualne-funkcije">
<span id="virtual"></span><h2>Polimorfizem in virtualne funkcije<a class="headerlink" href="#polimorfizem-in-virtualne-funkcije" title="Link to this heading">¶</a></h2>
<p>Pred branjem morate biti seznanjeni s snovjo v poglavju <a class="reference internal" href="pointers#pointers"><span class="std std-ref">Kazalci in reference</span></a>.
Zaradi enostavnosti bomo v tem poglavju uporabljali navadne kazalce,
vendar vse deluje enako tudi s pametnimi kazalci.</p>
<p>Polimorfizem (angl. <em>polymorphism</em>) pomeni “imeti več oblik” in se v kontekstu
dedovanja nanaša na to, imamo lahko več podrazredov istega nadrazreda, ki
se obnašajo vsak na svoj način, medtem ko še vedno imajo iste metode,
predpisane s strani nadrazreda.</p>
<p>Denimo da imamo spodnjo situacijo:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hov&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Cat</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Nyaa&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Cat</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Animal</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Ko poženemo zgornji program, ki radi, da se izpiše <code class="docutils literal notranslate"><span class="pre">Nyaa</span></code> in <code class="docutils literal notranslate"><span class="pre">Hov</span></code>,
saj smo v <code class="docutils literal notranslate"><span class="pre">v</span></code> shranili mačko in psa. Toda, kot smo se naučili v razdelku
<a class="reference internal" href="#slicing"><span class="std std-ref">Slicing</span></a> se objekta <code class="docutils literal notranslate"><span class="pre">Cat</span></code> in <code class="docutils literal notranslate"><span class="pre">Dog</span></code> pretvorita v <code class="docutils literal notranslate"><span class="pre">Animal</span></code> in
vse dodatne informacije izginejo. Izpiše se torej dvakrat prazen niz.
Toda, če uporabimo kazalce, problem z
različnimi velikostmi objektov, ko nadrazredu priredimo podrazred, izgine.
Oba objekta sta kazalca enake velikosti (kakršna pač je na tem sistemu)
in lahko kažeta na različno velika objekta. toda, to da še ni ovir, ne pomeni da
je obnašanje tako. Koda spodaj</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Cat</span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">();</span>
<span class="n">Dog</span><span class="o">*</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="p">();</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Animal</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>še vedno izpiše dva prazna niza: oba objekta sta kazalca na tip <code class="docutils literal notranslate"><span class="pre">Animal</span></code>
in enako kot prej se pokliče metoda <code class="docutils literal notranslate"><span class="pre">oglasanje</span></code> na tipu <code class="docutils literal notranslate"><span class="pre">Animal</span></code>.</p>
<p>To, da bi se metoda <code class="docutils literal notranslate"><span class="pre">oglasanje</span></code> obnašala drugače, glede na to ali je vrednost,
na katero kaže kazalec, v resnici tipa <code class="docutils literal notranslate"><span class="pre">Cat</span></code>, stane nekaj operacij. Pri drugih
jezikih (npr. Java) se to vedno preveri in uporabnik za vsak klic plača te
operacije, filozofija C++ pa je, da uporabnik ne plača, za stvari, ki jih ni
zahteval in moramo polimorfično obnašanje posebej zahtevati.</p>
<p>To storimo z besedo <code class="docutils literal notranslate"><span class="pre">virtual</span></code> pred neko metodo. Ta označuje, da pri tej metodi
podpiramo polimorfično obnašanje in dovolimo, da jo podrazredi predefinirajo
(overridajo). Virtualne funkcije niso virtualne v smislu da ne obstajajo (te
bomo spoznali kasneje), ampak so virtualne zgolj v smislu, da deklaracija ni
direktno povezana z implementacijo. Kot bomo videli, so to funkcije, za katere
je implementirano dinamično razvrščanje (angl. <em>dynamic dispatch</em>).</p>
<p>Spremenimo definicijo <code class="docutils literal notranslate"><span class="pre">Animal</span></code> v sledečo.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Vse kar smo dodali, je beseda <code class="docutils literal notranslate"><span class="pre">virtual</span></code>, ki označuje, da naj se
pri klicu funkcije <code class="docutils literal notranslate"><span class="pre">oglasanje</span></code> uporabi polimorfizem: med izvajanjem programa
(in ne pri prevajanju, kot ponavadi), se glede na trenuten tip kazalca na
objekt izbere, katera implementacija virtualne funkcije <code class="docutils literal notranslate"><span class="pre">oglasanje</span></code> bo
poklicana. Izbere se tisto, ki pripada objektu, ki je dejansko shranjen
na mestu, kamor kaže kazalec. S spremenjeno definicijo, bi zadnji primer izpisal
<code class="docutils literal notranslate"><span class="pre">Nyaa</span></code> in <code class="docutils literal notranslate"><span class="pre">Hov</span></code>, saj je prvi objekt (čeprav shranjen kot <code class="docutils literal notranslate"><span class="pre">Animal*</span></code>) v
resnici tipa <code class="docutils literal notranslate"><span class="pre">Cat*</span></code> in bi se poklicala njegova metoda <code class="docutils literal notranslate"><span class="pre">ogasanje</span></code> (ki
je predefinirala tisto iz <code class="docutils literal notranslate"><span class="pre">Animal</span></code>). Enako se zgodi za drugi element.
Temu obnašanju pravimo polimorfizem in dinamičnemu klicanju glede na tip objekta
med izvajanjem <em>dynamic dispatch</em>. Enako obnašanje dobimo, če kličemo metode
prek referenc na objekte.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">oglasaj</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Animal</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">oglasaj</span><span class="p">(</span><span class="n">Cat</span><span class="p">());</span>
<span class="w">    </span><span class="n">oglasaj</span><span class="p">(</span><span class="n">Dog</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Izpiše se <code class="docutils literal notranslate"><span class="pre">Nyaa</span></code> in <code class="docutils literal notranslate"><span class="pre">Hov</span></code>, saj je klic prek reference polimorfičen.</p>
<p>Predefinicije virtualnih funkcij so avtomatsko virtualne, tako da ni potrebno
ponovno pred njih pisati besede <code class="docutils literal notranslate"><span class="pre">virtual</span></code>. Da pa se izognemo morebitnim
napakam, je dobro uporabiti besedo <code class="docutils literal notranslate"><span class="pre">override</span></code> s katero prevajalniku (in
programerju) nakažemo, da je mišljeno, da ta funkcija predefinira neko virtualno
funkcijo iz nadrazreda. Primer, ko nam to pomaga, sledi. Denimo, da definiramo
podrazred <code class="docutils literal notranslate"><span class="pre">Dog</span></code> tako, pri čemer si mislimo, da smo predefinirali
<code class="docutils literal notranslate"><span class="pre">oglasanje</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hov&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Toda, Če bi pognali <code class="docutils literal notranslate"><span class="pre">Animal*</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">new</span> <span class="pre">Dog();</span> <span class="pre">cout</span> <span class="pre">&lt;&lt;</span> <span class="pre">a-&gt;oglasanje()</span> <span class="pre">&lt;&lt;</span> <span class="pre">endl;</span></code>
bi bili najprej prijetno presenečeni, ker prevajalnik nebi javil napak,
in nato neprijetno presenečeni, ker bi se izpisal prazen niz.
To je zato, ker smo pozabili <code class="docutils literal notranslate"><span class="pre">const</span></code> pri zgornji metodi in je prevajalnik
to smatral kot drugo metodo, ki je samo skrila (v smislu razdelka <a class="reference internal" href="#hiding"><span class="std std-ref">Hiding</span></a>)
metodo <code class="docutils literal notranslate"><span class="pre">oglasanje</span></code> iz nadrazreda. Če pa uporabimo <code class="docutils literal notranslate"><span class="pre">override</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hov&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>pa nas prevajalnik posvari:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>program.cpp:9:12: error: ‘std::__cxx11::string Dog::oglasanje()’ marked ‘override’, but does not override
     string oglasanje() override { return &quot;Hov&quot;; }
            ^~~~~~~~~
</pre></div>
</div>
<p>Prevajalnik Clang, nam celo predlaga, da smo morda mislili predefinirati metodo, ki
smo jo ponesreči skrili in celo pove, v čem se razlikujeta:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>program.cpp:9:24: error: non-virtual member function marked &#39;override&#39; hides virtual member function
    string oglasanje() override { return &quot;Hov&quot;; }
                       ^
programprogram.cpp:5:20: note: hidden overloaded virtual function &#39;Animal::oglasanje&#39; declared here: different qualifiers (const vs none)
    virtual string oglasanje() const { return &quot;&quot;;}
                   ^
</pre></div>
</div>
<p>Podobno se zgodi, če smo ponesreči pozabili metodo v nadrazredu označiti kot
virtualno, čeprav smo popolnoma pravilno predefinirali metodo spodaj. V tem
primeru se brez <code class="docutils literal notranslate"><span class="pre">override</span></code> prevajalnik prav tako ne pritoži in program samo ne
deluje po naših željah, medtem ko z <code class="docutils literal notranslate"><span class="pre">override</span></code> dobimo jasno napako</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>program.cpp:9:30: error: only virtual member functions can be marked &#39;override&#39;
    string oglasanje() const override { return &quot;Hov&quot;; }
                             ^~~~~~~~~
</pre></div>
</div>
<p>Uporaba <code class="docutils literal notranslate"><span class="pre">override</span></code> je tako zelo priporočena in pri prevajalnikih obstajajo
celo zastavice, ki opozorijo, da smo to besedo pozabili.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Polimorfično obnašanje dobimo samo, če imamo oboje: <strong>virtualno funkcijo</strong>, ki smo
jo klicali prek <strong>kazalca</strong> ali <strong>reference</strong>, ki je tipa našega nadrazreda.</p>
<p>To pomeni, da tudi če je metoda virtualna, pa jo kličemo direktno na
objektu nadrazreda, se bo klicala metoda nadrazreda, in ne od potencialnega
otroka (zaradi slicinga). Prav tako, tudi če kličemo metodo prek kazalca,
ki je z enakim imenom definirana v podrazredu, pa je nismo označili kot
virtualne, se bo zopet poklicala metoda nadrazreda. To pokaže naslednji
primer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A::f&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A::g&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B::f&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">g</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B::g&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">ab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">();</span>
<span class="w">    </span><span class="n">a</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">ab</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">ab</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;------------&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">pa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">B</span><span class="o">*</span><span class="w"> </span><span class="n">pb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">pab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">pa</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">pb</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">pab</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">pab</span><span class="o">-&gt;</span><span class="n">g</span><span class="p">();</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;------------&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">B</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rab</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">ra</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">ra</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">rb</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">rb</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="w">    </span><span class="n">rab</span><span class="p">.</span><span class="n">f</span><span class="p">();</span><span class="w"> </span><span class="n">rab</span><span class="p">.</span><span class="n">g</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pri prvem sklopu se vedno kličejo metode (ne glede na virtualnost)
pripadajoče tipu objekta, saj kličemo direktno prek objekta.
Pri drugem in tretjem sklopu pa se metoda <code class="docutils literal notranslate"><span class="pre">g</span></code> pri klicu
prek kazalca ali reference kliče polimorfično in tudi v zadnji vrstici dobimo
izpis <code class="docutils literal notranslate"><span class="pre">B::g</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>A::f
A::g
B::f
B::g
A::f
A::g
------------
A::f
A::g
B::f
B::g
A::f
B::g
------------
A::f
A::g
B::f
B::g
A::f
B::g
</pre></div>
</div>
</div>
<p>Stvari postanejo komplicirane, če imamo na kupu več funkcij z enakim imenom in
različnimi parametri, nekatere so virtualne, nekatere niso in lahko z
predefiniranjem neke metode uvedemo skrivanje neke druge…</p>
</section>
<section id="konstruktorji-in-virtualni-destruktorji">
<h2>Konstruktorji in virtualni destruktorji<a class="headerlink" href="#konstruktorji-in-virtualni-destruktorji" title="Link to this heading">¶</a></h2>
<p>Osnove o konstruktorjev in destruktorjev so razložene v razdelku
<a class="reference internal" href="objekti#constructors"><span class="std std-ref">Konstruktorji in destruktorji</span></a>, ta razdelek opisuje njihovo obnašanje pri dedovanju.</p>
<p>Če razred <code class="docutils literal notranslate"><span class="pre">B</span></code> deduje od razreda <code class="docutils literal notranslate"><span class="pre">A</span></code>, potem se vedno ko naredimo objekt tipa
<code class="docutils literal notranslate"><span class="pre">B</span></code> najprej pokliče konstruktor starša, nato pa še naš konstruktor. to med
drugim pomeni, da se v konstruktorju <code class="docutils literal notranslate"><span class="pre">B</span></code> lahko zanašamo na obstoj in pravilno
delovanje vseh metod objekta <code class="docutils literal notranslate"><span class="pre">A</span></code>. Tak sistem konstruiranja objektov
zagotavlja, da konstruktor <code class="docutils literal notranslate"><span class="pre">A</span></code> skrbi za vse, kar je v povezavi s tipom <code class="docutils literal notranslate"><span class="pre">A</span></code>,
konstruktor <code class="docutils literal notranslate"><span class="pre">B</span></code> pa za vse kar je v povezavi s tipom <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<p>Podobno velja tudi pri destruktorjih. Pri
uničenju objekta tipa <code class="docutils literal notranslate"><span class="pre">B</span></code> se najprej pokliče destruktor <code class="docutils literal notranslate"><span class="pre">B</span></code>, ki kot zadnje
dejanje pokliče starševski destruktor.</p>
<p>Primer (z napako, razloženo kasneje):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A ctor&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A dtor&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B ctor&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">B</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B dtor&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Zgornja koda izpiše</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">ctor</span>
<span class="n">B</span> <span class="n">ctor</span>
<span class="n">B</span> <span class="n">dtor</span>
<span class="n">A</span> <span class="n">dtor</span>
</pre></div>
</div>
<p>Poglejmo si še, kaj se zgodi, če kličemo objekte prek pointerjev.
Funkcijo <code class="docutils literal notranslate"><span class="pre">main</span></code> od zgoraj spremenimo v</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">B</span><span class="p">();</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>in ko jo poženemo, dobimo</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">ctor</span>
<span class="n">B</span> <span class="n">ctor</span>
<span class="n">A</span> <span class="n">dtor</span>
</pre></div>
</div>
<p>Kot vidimo, se destruktor <code class="docutils literal notranslate"><span class="pre">B</span></code> ni poklical. To pravzaprav ni nepričakovano, ker
smo <code class="docutils literal notranslate"><span class="pre">b</span></code> naredili kot objekt tipa <code class="docutils literal notranslate"><span class="pre">B</span></code>, sta te poklicala oba konstruktorja,
nato smo ga shranili v kazalec tipa <code class="docutils literal notranslate"><span class="pre">A</span></code>, ko pa smo ga uničili, se je poklical
le destruktor <code class="docutils literal notranslate"><span class="pre">A</span></code>, saj je to bil takratni tip objekta. Toda to pomeni, da je
pol objekta (<code class="docutils literal notranslate"><span class="pre">B</span></code>-jev del) ostalo nepospravljenega. Obnašanje je podobno kot
pri virtualnih in navadnih funkcijah (glej <a class="reference internal" href="#virtual"><span class="std std-ref">Polimorfizem in virtualne funkcije</span></a>). Rešitev je, da se
destruktor <code class="docutils literal notranslate"><span class="pre">B</span></code> označi kot virtualen. Če vemo, da objekta ne bomo nikoli
uničevali prek kazalca na starševski razred, tega ni potrebno storiti, vendar se je
za vsak slučaj dobro navaditi, da pri vsakem dedovanju označimo destruktor v
spodnjem razredu kot virtualen, da se izognemo potencialnim težavam v
prihodnosti.</p>
<p>Ko destruktor <code class="docutils literal notranslate"><span class="pre">B</span></code> izgleda kot <code class="docutils literal notranslate"><span class="pre">~B()</span> <span class="pre">{</span> <span class="pre">cout</span> <span class="pre">&lt;&lt;</span> <span class="pre">&quot;B</span> <span class="pre">dtor&quot;</span> <span class="pre">&lt;&lt;</span> <span class="pre">endl;</span> <span class="pre">}</span></code>, dobimo
pričakovan izhod</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">ctor</span>
<span class="n">B</span> <span class="n">ctor</span>
<span class="n">B</span> <span class="n">dtor</span>
<span class="n">A</span> <span class="n">dtor</span>
</pre></div>
</div>
<p>Povedali smo, da prevajalnik za nas pokliče starševske konstruktorje, kar drži,
če obstaja default konstruktor za starša.
Če ima starševski konstruktor parametre, ga moramo pri konstruiranju
poklicati eksplicitno:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">B</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">  </span><span class="c1">// klic starševega konstruktorja</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="ciste-virtualne-funkcije-in-abstraktni-razredi">
<h2>Čiste virtualne funkcije in abstraktni razredi<a class="headerlink" href="#ciste-virtualne-funkcije-in-abstraktni-razredi" title="Link to this heading">¶</a></h2>
<p>TODO</p>
<p>Primer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Being</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="nf">zadnje_besede</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">die</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">zadnje_besede</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;bitje&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Being</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Being</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Plant</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Being</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">zadnje_besede</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Screw vegans.&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Being</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">zadnje_besede</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Ouch.&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Being</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; animal:&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Hov &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">zadnje_besede</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Wasn&#39;t I a good boy?&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">os</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Animal</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="n">os</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Dog: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Cat</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Nyaa&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Duck</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="nf">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Quack&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Animal a;</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Piki&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Fido&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Duck</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Jakob&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    for (const auto&amp; p : v) {</span>
<span class="cm">        cout &lt;&lt; p-&gt;oglasanje() &lt;&lt; endl;</span>
<span class="cm">    }*/</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Being</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Piki&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Duck</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="n">b</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Plant</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">die</span><span class="p">();</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// cout &lt;&lt; typeid(p.get()).name() &lt;&lt; endl;</span>
<span class="w">            </span><span class="n">Animal</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a is null&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// cout &lt;&lt; &quot;here&quot; &lt;&lt; endl;</span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">oglasanje</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">                </span><span class="c1">// cout &lt;&lt; &quot;here&quot; &lt;&lt; endl;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_cast</span><span class="o">&amp;</span><span class="w"> </span><span class="n">bc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;to ni Animal&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;------------------&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="n">Dog</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="s">&quot;Fifi&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="daljsi-primer-uporabe-risanje-oblik">
<h2>Daljši primer uporabe - risanje oblik<a class="headerlink" href="#daljsi-primer-uporabe-risanje-oblik" title="Link to this heading">¶</a></h2>
<p>TODO</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="objekti" class="btn btn-neutral float-left" title="Objekti" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="templates" class="btn btn-neutral float-right" title="Predloge (templates)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2014–2019, Natan Žabkar, Jure Slak, Maks Kolman, Ines Meršak.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>