% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Programerski krožek na Gimnaziji Vič Documentation}
\date{September 16, 2014}
\release{0.1}
\author{Natan Žabkar, Jure Slak}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Vsebina:


\chapter{Osnove}
\label{skripta/osnove:programerski-krozek-na-gimnaziji-vic}\label{skripta/osnove::doc}\label{skripta/osnove:osnove}
V tem poglavju si bomo ogledali osnove programiranja, s katerimi lahko vzpostavimo
osnovno komunikacijo z računalnikom in naredimo zelo enostavne programe.


\section{Spremenljivke}
\label{skripta/osnove:spremenljivke}
Spremenljivke so prostori v spominu z določenim imenom, v katere lahko spravimo
neko vrednost. Tako lahko npr. pod ime \code{leta} spravimo vrednost \code{5}. V
osnovi ločimo tri tipe spremenljivk - \code{float} (realna števila), \code{int} (cela
števila) in \code{string} (nize znakov). Začetek in konec \code{stringa} je označen z
dvojnim ali enojnim narekovajem (\code{"} ali \code{'}). Python tipe spremenljivk
določa samodejno.

Spremenljivke se definira na naslednji način:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{ime} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Andreja}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{leta} \PYG{o}{=} \PYG{n}{x} \PYG{o}{+} \PYG{n}{y}
\end{Verbatim}

\begin{notice}{hint}{Hint:}
Znak = v programiranju nima istega pomena kot v matematiki. = pravzaprav
pomeni ``vrednost na desni zapiši v spremenljivko na levi''. Torej bo ukaz x =
x + 2 dejansko pomenil ``x povečaj za 2''.
\end{notice}


\section{Komentarji}
\label{skripta/osnove:komentarji}
Komentarji so programerjeve opombe v kodi, namenjene bralcu -- sebi ali nekomu drugemu,
ki bo to bral za njim. Interpreter jih ignorira. V Pythonu so komentarji enovrstični in
ze začnejo z znakom \code{\#}. Vsi znaki v vrstici od znaka \code{\#} so ignorirani. Komentarje se
ponavadi napiše pred manj razmljiv del kode, da obrazložimo njeno delovanje, ali pa če
želimo kakšen del kode trenutno umakniti iz programa, ne da bi ga izbrisali. Komentarji
pogosto tudi obrazložijo in dokumentirajo kodo in narekujejo njeno uporabo.

Primer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ime} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Janez}\PYG{l+s}{\PYGZdq{}}  \PYG{c}{\PYGZsh{} ime naj bo brez presledkov in naj se začne z veliko začetnico}
\PYG{c}{\PYGZsh{} v absx shranimo absolutno vrednost x}
\PYG{n}{x} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8}
\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{n}{absx} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{x}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{absx} \PYG{o}{=} \PYG{n}{x}
\end{Verbatim}


\section{Input in output}
\label{skripta/osnove:input-in-output}
Input in output pomeni branje uporabnikovega vpisa in izpisovanje na zaslon.
Uporabili smo funkcije \code{input}, \code{int}, \code{print}, \code{format}.
\index{input() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{skripta/osnove:input}\pysiglinewithargsret{\bfcode{input}}{\emph{niz\_znakov}}{}
Izpiše niz znakov in vrne to, kar je uporabnik vtipkal.

\end{fulllineitems}

\index{int() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{skripta/osnove:int}\pysiglinewithargsret{\bfcode{int}}{\emph{niz\_znakov}}{}
Niz znakov spremeni v dejansko celo število, s katerim znamo računati. Če je
parameter že celo število, ne pride do sprememb.

\end{fulllineitems}

\index{print() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{skripta/osnove:print}\pysiglinewithargsret{\bfcode{print}}{\emph{niz\_znakov}}{}
Izpiše niz znakov niz\_znakov.

\end{fulllineitems}

\index{str (built-in class)}

\begin{fulllineitems}
\phantomsection\label{skripta/osnove:str}\pysigline{\strong{class }\bfcode{str}}~\index{format() (str method)}

\begin{fulllineitems}
\phantomsection\label{skripta/osnove:str.format}\pysiglinewithargsret{\bfcode{format}}{\emph{p1}, \emph{p2}, \emph{p3}, \emph{...}}{}
Na mesto označeno z \{0\} vstavi p1, na \{1\} vstavi p2, ...

\end{fulllineitems}


\end{fulllineitems}


Primer:


\section{If stavki}
\label{skripta/osnove:if-stavki}
\code{If stavek} se uporablja vsakič, kadar hočemo, da se naš program obnaša
drugače pod drugačnimi pogoji. Če je pogojev več, lahko za \code{if} uporabimo še
\code{elif} (else if), ki doda dodatne pogoje. Za konec pa lahko damo še \code{else},
ki se izvede takrat, ko ni bil izpolnjen noben od pogojov v \code{if} in \code{elif}
stavkih. \code{elif} in \code{else} deli niso obvezni.

Sintaksa if stavkov je naslednja (pazljivi moramo biti na zamik po if stavku -
dobimo ga tako, da pritisnemo tabulator, ki se nahaja nad caps lock tipko na
tipkovnici):

\begin{Verbatim}[commandchars=\\\{\}]
if pogoj:
    Koda, ki se izvede, če je izpolnjen pogoj
elif pogoj2:
    Koda, ki se izvede, če je izpolnjen pogoj2
else:
    Koda, ki se izvede, če ni izpolnjen noben od zgornjih pogojev
\end{Verbatim}


\subsection{Pogoji}
\label{skripta/osnove:pogoji}
Pogoji so lahko enostavni ali sestavljeni. Enostavni pogoji so npr. primerjanje
enakosti (je enako \code{==}, ni enako \code{!=}), primerjanje vrednosti (večje
\code{\textgreater{}}, večje ali enako \code{\textgreater{}=}, manjše \code{\textgreater{}}, manjše ali enako \code{\textless{}=}),
sestavljeni pa so narejeni iz kombinacije enostavnih z uporabo matematičnih
operacij \code{NOT}, \code{AND}, \code{OR}, \code{XOR} itd.

Primer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Vpisite stevilo: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{x} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{100}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x je vecji od 100}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x je pozitiven}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{elif} \PYG{n}{x} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x je \PYGZhy{}5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{x je negativen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}


\section{Zanke}
\label{skripta/osnove:zanke}
Zanke se uporablja takrat, ko moramo neko stvar ponoviti večkrat. Če moramo
npr. izpisati vsa števila med 1 in 100 uporabimo zanko. Če hočemo isto stvar
ponoviti 3x, uporabimo zanko. Če bi radi, da se nekaj dogaja, dokler ni
izpolnjen nek pogoj (npr. vtipkavaj geslo, dokler ne vtipkaš pravilnega),
uporabimo zanko.


\subsection{While zanka}
\label{skripta/osnove:while-zanka}
\begin{Verbatim}[commandchars=\\\{\}]
while pogoj:
    Koda, ki se izvaja dokler je pogoj izpolnjen
\end{Verbatim}

\code{while} zanko uporabimo takrat, ko se mora nekaj izvajati dokler je pogoj
izpolnjen. Pri while zanki moramo biti zelo pozorni na neskončne zanke.
Neskončna zanka se zgodi takrat, ko je pogojvedno izpolnjen, program pa bo
tekel v neskončnost. Če se nam to slučajno zgodi, pritisnemo kombinacijo tipk
\code{ctrl+c}, s čimer program prekinemo.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Uporabnik vpisuje geslo. Če 5x zaporedoma vpiše napačno geslo je izključen}
\PYG{l+s+sd}{iz sistema (za to poskrbi spremenljivka števec) \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{geslo} \PYG{o}{=} \PYG{l+m+mi}{123}
\PYG{n}{stevec} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Vpisi geslo: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{while} \PYG{n}{x} \PYG{o}{!=} \PYG{n}{geslo}\PYG{p}{:}
    \PYG{n}{stevec} \PYG{o}{=} \PYG{n}{stevec} \PYG{o}{+} \PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{stevec} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{4}\PYG{p}{:}
        \PYG{k}{break}
    \PYG{n}{x} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ponovno vpisi: }\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{x} \PYG{o}{!=} \PYG{n}{geslo}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Preveckrat si poskusil, zakljenjen si iz sistema!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Bravo!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}


\subsection{For zanka}
\label{skripta/osnove:for-zanka}
\begin{Verbatim}[commandchars=\\\{\}]
for spremenljivka in množica:
    Koda, ki se izvaja dokler spremenljivka ne preteče vseh elementov množice
\end{Verbatim}

\code{for} zanko uporabimo takrat, ko želimo, da naša spremenljivka preteče vse
elemente neke množice. Množica je lahko seznam (\code{list}), niz znakov
(\code{string}), slovar (\code{dict}), \code{tuple}, \code{iterator} ali kaj podobnega,
bolj podrobno si bomo to pogledali pozneje. Zaenkrat bomo for zanko večinoma
uporabljali skupaj s funkcijo \code{range(x)}, ki vrne vse elemente od \code{0} do
\code{x-1} (torej \code{range(5)} vrne \code{{[}0, 1, 2, 3, 4{]}}).

Primer:


\subsection{Break}
\label{skripta/osnove:break}
Če kjerkoli v zanki napišemo ukaz \code{break}, bo zanka takrat prekinjena. Občasno se
programira tudi tako, da zanalašč naredimo neskončno zanko, in potem ob
določenih pogojih pokličemo \code{break}.

Ukaz break prekine le `najbližjo' zanko -- če imamo gnezdenih več zank (npr. for
zanka znotraj while zanke) se bo prekinila le notranja zanka (v našem primeru
for zanka).


\chapter{Podatkovni tipi}
\label{skripta/podatkovni_tipi::doc}\label{skripta/podatkovni_tipi:podatkovni-tipi}
V tem poglavju bomo predstavili podatkovne tipe, kaj so in zakaj so pomembni, kako jih
uporabljamo in kateri obstajajo. Nekatere si bomo tudi podrobneje ogledali.


\section{Uvod}
\label{skripta/podatkovni_tipi:uvod}
Program za svoje delovanje potrebuje podatke, števila, besede, slike, tabele, ... Take in
drugačne tipe podatkov računalnik hrani v pomnilniku, v programu pa imamo podatke na
voljo kot spremenljivke. Python ima veliko podatkovnih tipov, na kratko smo si že
pogledali števila in nize znakov. Različni tipi podpirajo različne operacije in so
primerni za različne priložnosti, zato jih je potrebno poznati, da jih znamo pravilno
izbirati.


\section{Števila}
\label{skripta/podatkovni_tipi:stevila}
Python podpira (na grobo) dve vrsti števil -- cela števila in decimalna števila. Za cela
števila ni omejitve na dolžino, decimalna števila pa imajo standardne omejitve, a so za
naše računanje dovolj dobra. Veljavne vrednosti decimalnih števila sta tudi obe
neskončnosti in \code{nan}, ki pomeni ``Not a number''. Cela števila dobimo iz drugih tipov s
funkcijo \code{int}, decimalna pa s funkcijo \code{float}.

Primer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{238743234}
\PYG{n}{b} \PYG{o}{=} \PYG{l+m+mf}{123.5324}
\PYG{n}{c} \PYG{o}{=} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}    \PYG{c}{\PYGZsh{} rezultat je decimalno število}
\PYG{n}{k} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}
\PYG{n}{r} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{123.3223e12}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mh}{0xdead}   \PYG{c}{\PYGZsh{} z je sedaj 57005}
\PYG{n}{inf} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{inf}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

S števili lahko računamo (duh), tip rezultata je odvisen od tipov operandov.
Če je eden izmed njiju decimalno število, potem je rezultat decimalen, Rezultat operacije
dveh celih števil je celo število. Izjema je deljenje, ki vedno vrne decimalno število.
Če želimo dobiti celoštevilsko deljenje, ki zaokrožuje proti 0, uporabimo operator \code{//}.


\section{Seznami}
\label{skripta/podatkovni_tipi:seznami}
Največji problem enostavnih spremenljivk je v tem, da lahko vsebujejo le en podatek. Tako
moramo npr.  če hočemo od uporabnika dobiti 10 stvari, za to narediti tudi 10
spremenljivk. Kaj pa, če hočemo stvari dobiti 1000? Ali pa 100.000?

Tu v poštev pridejo seznami. Sezname prav tako kot spremenljivko spravimo pod neko ime,
označujejo pa jih oglati oklepaji \code{{[}} in \code{{]}}. Med oglatimi oklepaji lahko navedemo poljubno
število spremenljivk, ki bodo vse vsebovane v seznamu:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{seznam} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mf}{66.12}\PYG{p}{]}
\end{Verbatim}

Kot vidimo, lahko seznam vsebuje mešane tipe spremenljivk - vsebuje lahko nekaj celih
števil, nekaj decimalnih števil in nekaj nizov znakov. Sezname iz drugih tipov dobimo s
funkcijo \code{list}.


\subsection{Dostopanje elementov seznama}
\label{skripta/podatkovni_tipi:dostopanje-elementov-seznama}
Dostopanje do elementov seznama je malce drugačno kot pri navadnih spremenljivkah. Če
namreč vpišemo samo ime seznama, bomo seveda dobili vse elemente -- v seznamu. Če pa hočemo
dostopati do elementov, moramo za imenom seznama v oglatih oklepajih napisati njegovo
mesto. Pozor, računalnik ponovno šteje od 0 naprej (torej je prvo mesto označeno z nič,
drugo z 1, ...). Če poskusimo dostopati ``prepozen'' element (npr. št. 12 v seznamu s
štirimi elementi) dobimo napako. V številko elementa pa lahko vpišemo tudi negativno
število, kjer -1 pomeni zadnji element, -2 predzadnji itd.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{66.12}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{g+go}{66.12}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}
\end{Verbatim}


\subsection{Dodajanje in odvzemanje elementov seznama}
\label{skripta/podatkovni_tipi:dodajanje-in-odvzemanje-elementov-seznama}
V seznam seveda lahko dodajamo in iz njega odvzemamo elemente. Za te (in ostale operacije
na seznamih) uporabljamo metode. Do metod dostopamo tako, da po imenu seznama napišemo \code{.},
za njo pa ime metode (seznam.metoda()). Najbolj uporabljane metode so naslednje:
\index{list (built-in class)}

\begin{fulllineitems}
\phantomsection\label{skripta/podatkovni_tipi:list}\pysigline{\strong{class }\bfcode{list}}~\index{append() (list method)}

\begin{fulllineitems}
\phantomsection\label{skripta/podatkovni_tipi:list.append}\pysiglinewithargsret{\bfcode{append}}{\emph{vrednost}}{}
V seznam na koncu doda element z vrednostjo \code{vrednost}.

\end{fulllineitems}

\index{insert() (list method)}

\begin{fulllineitems}
\phantomsection\label{skripta/podatkovni_tipi:list.insert}\pysiglinewithargsret{\bfcode{insert}}{\emph{index}, \emph{vrednost}}{}
V seznam pred \code{index}-to mesto doda element z vrednostjo \code{vrednost}.

\end{fulllineitems}

\index{pop() (list method)}

\begin{fulllineitems}
\phantomsection\label{skripta/podatkovni_tipi:list.pop}\pysiglinewithargsret{\bfcode{pop}}{\emph{index}}{}
Iz seznama pobriše \code{index}-ti element in vrne njegovo vrednost.

\end{fulllineitems}


\end{fulllineitems}


Še primeri uporabe metod:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{66.12}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}
\PYG{g+go}{[1, 5, \PYGZsq{}abc\PYGZsq{}, 66.12, 16]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{o}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello World!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}
\PYG{g+go}{[1, 5, \PYGZsq{}Hello World!\PYGZsq{}, \PYGZsq{}abc\PYGZsq{}, 66.12, 16]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{g+go}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}
\PYG{g+go}{[5, \PYGZsq{}Hello World!\PYGZsq{}, \PYGZsq{}abc\PYGZsq{}, 66.12, 16]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{g+go}{66.12}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}
\PYG{g+go}{[5, \PYGZsq{}Hello World!\PYGZsq{}, \PYGZsq{}abc\PYGZsq{}, 16]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{seznam}
\PYG{g+go}{[\PYGZsq{}Hello World!\PYGZsq{}, \PYGZsq{}abc\PYGZsq{}, 16]}
\end{Verbatim}


\section{Nizi znakov}
\label{skripta/podatkovni_tipi:nizi-znakov}
Niz zankov (string) v pythonu naredimo tako da, damo besedilo v enojne ali
dvojne narekovaje. Mogoči so tudi trojni narekovaji, ki segajo čez več vrstic.
Niz pa lahko uzstvarimo tudi iz kateregakoli drugega tipa s klicanjem funkcije
\code{str}. Primer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ime} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Janez}\PYG{l+s}{\PYGZdq{}}
\PYG{n}{priimek} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Novak}\PYG{l+s}{\PYGZsq{}}
\PYG{n}{kratek\PYGZus{}zivljenjepis} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s}{  Rodil: 1934}
\PYG{l+s}{  Živel na Primorkem.}
\PYG{l+s}{  Umrl: 2001}
\PYG{l+s}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{stevilka\PYGZus{}ampak\PYGZus{}ne\PYGZus{}cisto} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}
\PYG{n}{stevilka\PYGZus{}ampak\PYGZus{}spet\PYGZus{}ne\PYGZus{}cisto} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{134}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

Niz znakov \code{"abcd"} sli lahko nekako predstavljamo kot seznam \code{{[}'a', 'b',
'c', 'd'{]}}. Primerjava v Pythonu ni čisto popolna, saj elementov niza znakov ne
moremo spreminjati, pri branju elementov pa se obnaša popolnoma enako. Tako
npr. \code{niz{[}2{]}} pomeni tretji element niza znakov (torej tretja črka oz. znak).
\begin{description}
\item[{Torej -- nize znakov beremo na isti način kot sezname, spreminjati njihovih elementov pa ne moremo::}] \leavevmode
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Dober dan!}\PYG{l+s}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{!}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}\PYG{p}{[}\PYG{l+m+mi}{12}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}

\end{description}


\subsection{Brisanje in dodajanje v niz znakov}
\label{skripta/podatkovni_tipi:brisanje-in-dodajanje-v-niz-znakov}
Za razliko od seznamov nizi znakov nimajo metod \code{.append}, \code{.pop} in podobno.
Znamo pa nize znakov ``seštevati'' (znak + dva niza zlepi skupaj). Torej lahko
dodajanje znakov na konec dobimo s prištevanjem na konec, dodajanje znakov na
začetek pa s prištevanjem na začetek. Seveda s tem originalnega niza v resnici ne spremenimo na mestu,
saj moramo vrednost spet dodeliti neki (lahko isti) spremenljivki:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}
\PYG{g+go}{\PYGZsq{}Dober dan!\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz} \PYG{o}{=} \PYG{n}{niz} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ Kako se imate?}\PYG{l+s}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Dober dan! Kako se imate?}\PYG{l+s}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Lep pozdrav in }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{niz}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{niz}
\PYG{g+go}{\PYGZsq{}Lep pozdrav in Dober dan! Kako se imate?\PYGZsq{}}
\end{Verbatim}


\subsection{Spreminjanje elementov niza znakov}
\label{skripta/podatkovni_tipi:spreminjanje-elementov-niza-znakov}
Ker elementov ne moremo spremeniti direktno z ukazom niz{[}x{]} = `a' ali podobno, jih spreminjamo tako, da naredimo nov prazen niz, nato pa potujemo po starem nizu in prepisujemo črko po črko v nov niz. Vsakič ko srečamo znak, ki ga nočemo, ga preprosto ne prepišemo. Če pa srečamo znak, ki bi ga radi zamenjali, ga preprosto zamenjamo. Spodaj primer programa, ki v našem nizu vse samoglasnike nadomesti z zvezdico.
niz = `Lep pozdrav in Dober dan! Kako se imate?' nov\_niz = ``'' samoglasniki = ``aeiou'' for i in niz: if(i in samoglasniki): nov\_niz = nov\_niz + ``*'' else: nov\_niz = nov\_niz + i print(nov\_niz) \textgreater{}\textgreater{}\textgreater{} L*p p*zdr*v \emph{n D*b*r d*n! K*k} s* \emph{m*t}?

Zadnji dve vrstici sta kopija tega, kar se pojavi, ko program izvedemo.

Dokumentacija zunanjih vaj:


\chapter{tutorialsPythonBasic}
\label{autodoc/modules:tutorialspythonbasic}\label{autodoc/modules::doc}

\chapter{Indeksi in tabele}
\label{index:indeksi-in-tabele}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
