

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Kazalci in reference &mdash; Programerski krožek na Gimnaziji Vič 0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
    <link rel="top" title="Programerski krožek na Gimnaziji Vič 0.1 documentation" href="../../index.html"/>
        <link rel="up" title="C++" href="../../c++.html"/>
        <link rel="next" title="Objekti" href="objekti.html"/>
        <link rel="prev" title="Funkcije" href="funkcije.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../index.html" class="fa fa-home"> Programerski krožek na Gimnaziji Vič</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul>
<li class="toctree-l1"><a class="reference internal" href="../../python.html">Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../python/osnove.html">Osnove</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/turtle.html">Želvja grafika</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/podatkovni_tipi.html">Podatkovni tipi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/funkcije_in_classi.html">Funkcije in razredi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/datoteke.html">Datoteke</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/baze_podatkov.html">Podatkovne baze</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/tkinter.html">Tkinter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/knjiznice.html">Nameščanje knjižnic</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/knjiznice.html#python-3-programi-v-sublime-text">Python 3 programi v Sublime Text</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python/pygame.html">Pygame</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../python-vaje.html">Python vaje</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/osnove.html">Osnovne vaje</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/turtle.html">Vaje iz želvje grafike</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/podatkovni_tipi_in_funkcije.html">Vaje iz podatkovnih tipov in funkcij</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/datoteke.html">Datoteke</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/bozicne-vaje/vaje.html">Božične vaje</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/vislice.html">Vislice</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/messenger.html">Facebook messenger bot</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/pogovor.html">Zakodiran pogovor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/kvazi_besede.html">Psevdo besede</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/mario_vs_snake.html">Mario vs Snake</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python-vaje/projekti.html">Projekti dijakov</a></li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../c++.html">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="uvod.html">Uvod</a></li>
<li class="toctree-l2"><a class="reference internal" href="osnove.html">Osnove</a></li>
<li class="toctree-l2"><a class="reference internal" href="podatkovni_tipi.html">Podatkovni tipi</a></li>
<li class="toctree-l2"><a class="reference internal" href="enum.html">Enum</a></li>
<li class="toctree-l2"><a class="reference internal" href="funkcije.html">Funkcije</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Kazalci in reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="objekti.html">Objekti</a></li>
<li class="toctree-l2"><a class="reference internal" href="dedovanje.html">Dedovanje</a></li>
<li class="toctree-l2"><a class="reference internal" href="templates.html">Predloge (templates)</a></li>
<li class="toctree-l2"><a class="reference internal" href="organizacija.html">Organizacija kode</a></li>
<li class="toctree-l2"><a class="reference internal" href="izjeme.html">Izjeme (exceptions)</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../c++-vaje.html">C++ vaje</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../c++-vaje/procesiranje_podatkov.html">Procesiranje podatkov</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sql.html">SQL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sql/osnove.html">Osnove SQL</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../git.html">Git</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../git/uvod.html">Uvod</a></li>
<li class="toctree-l2"><a class="reference internal" href="../git/namestitev.html">Namestitev</a></li>
<li class="toctree-l2"><a class="reference internal" href="../git/osnove.html">Osnove</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../opengl.html">OpenGL</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../opengl/osnove.html">Osnove</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../razbijanje.html">Kriptografija</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../sifre/crypto.html">Možni napadi</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../autodoc/modules.html">Dokumentacija</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../autodoc/tutorialsPythonBasic.html">tutorialsPythonBasic package</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../lov-na-zaklad.html">Lov na zaklad</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../lov-na-zaklad/2015.html">Lov na zaklad 2015</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lov-na-zaklad/2016.html">Lov na zaklad 2016</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lov-na-zaklad/2017.html">Lov na zaklad 2017</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Programerski krožek na Gimnaziji Vič</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../c++.html">C++</a> &raquo;</li>
      
    <li>Kazalci in reference</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="../../_sources/skripta/c++/pointers.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <div class="section" id="kazalci-in-reference">
<span id="pointers"></span><h1>Kazalci in reference<a class="headerlink" href="#kazalci-in-reference" title="Permalink to this headline">¶</a></h1>
<p>Kazalci so malo podobni iteratorjem,
ki smo jih srečali že v poglavju <a class="reference internal" href="podatkovni_tipi.html#podatkovnitipi"><em>Podatkovni tipi</em></a> / <a class="reference internal" href="podatkovni_tipi.html#iteratorjiuvod"><em>Iteratorji</em></a>,
reference pa smo že srečali v poglavju <a class="reference internal" href="funkcije.html#funkcijecpp"><em>Funkcije</em></a> / <a class="reference internal" href="funkcije.html#referenceuvod"><em>Reference in konstantne reference</em></a>.</p>
<div class="section" id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h2>
<p>Reference so spremenljivke, ki predstavljajo drugo ime za isto spremenljivko.
Če imamo spremenljivko tipa <tt class="docutils literal"><span class="pre">T</span></tt>, ima referenca nanjo tip <tt class="docutils literal"><span class="pre">T&amp;</span></tt>.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>V zgornjem primeru je <tt class="docutils literal"><span class="pre">b</span></tt> referenca na <tt class="docutils literal"><span class="pre">a</span></tt>, tako da ko spremenimo <tt class="docutils literal"><span class="pre">a</span></tt>, se
spremeni tudi <tt class="docutils literal"><span class="pre">b</span></tt> in obratno. Tako se izpiše <tt class="docutils literal"><span class="pre">8</span> <span class="pre">8</span></tt> in <tt class="docutils literal"><span class="pre">9</span> <span class="pre">9</span></tt>.</p>
<p>Lahko imamo tudi konstantne reference, to so reference, ki dovolijo spreminjanja
svoje vrednosti. Če imamo konstantno spremenljivko, lahko nanjo naredimo le
konstantno referenco, lahko pa konstantno referenco naredimo tudi na običajno
spremenljivko. O taki referenci razmišljamo kot o <em>pogledu</em> na spremenljivko,
saj lahko prek nje samo opazujemo, kaj se dogaja, ničesar pa ne moremo
spreminjati.</p>
<p>Referenca ne more biti prazna in vedno kaže na neko spremenljivko. Še vedno pa ne
na programerju, da pazi, da referenca kaže na veljavno spremenljivko, ki še ni
bila uničena. Tako npr. ne smemo iz funkcije vračati referenc na lokalne
spremenljivke. Primer reference na neveljavno spremenljivko:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">{</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Spremenljivka <tt class="docutils literal"><span class="pre">b</span></tt> je referenca na <tt class="docutils literal"><span class="pre">c</span></tt>, ki je že izbrisana. Program sicer v
veliko primerih pravilno izpiše 8, toda to ni zagotovljeno, se  splošnem ne
zgodi in se na tako obnašanje ne moremo zanašati. Zgornji program je preprosto
neveljaven, četudi občasno deluje.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Če definiramo več referenc na isti vrstici, moramo znak <tt class="docutils literal"><span class="pre">&amp;</span></tt> ponoviti.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span><span class="o">&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">v1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">v2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r3</span> <span class="o">=</span> <span class="n">v3</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">Zgornja koda ustvari tri reference <tt class="docutils literal"><span class="pre">r1,</span> <span class="pre">r2,</span> <span class="pre">r3</span></tt> na spremenljivke <tt class="docutils literal"><span class="pre">v1,</span> <span class="pre">v2,</span>
<span class="pre">v3</span></tt>.</p>
</div>
</div>
<div class="section" id="naslovi-spremenljivk">
<h2>Naslovi spremenljivk<a class="headerlink" href="#naslovi-spremenljivk" title="Permalink to this headline">¶</a></h2>
<p>C++ programerju omogoča, da pogleda, na katerem naslovu v spominu je shranjena
določena spremenljivka. O strukturi spomina bomo govorili kasneje, sedaj povejmo
le, da si program predstavlja, kot da je spomnim dolga enodimenzionalna
tabela, razdeljena na celice po 1 bajt. Vrednost spremenljivke <tt class="docutils literal"><span class="pre">int</span> <span class="pre">a</span></tt> je
shranjena nekje v tej tabeli; ker je <tt class="docutils literal"><span class="pre">int</span></tt> ponavadi velik 4 bajte zavzema 4
bajte. S pomočjo <em>operatorja</em> <tt class="docutils literal"><span class="pre">&amp;</span></tt>, ki se mu reče operator &#8220;naslov od&#8221;
(<em>address of</em>) lahko dobimo naslov spremenljivke. Če spremenljivka zavzema več
kot eno celico, dobimo naslov prve celice, ki jo zavzema. Primer:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Zgornja koda izpiše naslov spremenljivke, nekaj podobnega <tt class="docutils literal"><span class="pre">0x7ffe78a6f354</span></tt>,
kar je zaporedna številka (v šestnajstiškem sistemu) celice, kjer se <tt class="docutils literal"><span class="pre">a</span></tt> nahaja.
Naslov je vedno številka znane velikosti, praviloma 32 bitov na 32 bitnih
računalnikih in 64 bitov na 64 bitnih.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Za ustvarjenje referenc uporabljamo enak znak <tt class="docutils literal"><span class="pre">&amp;</span></tt> kot za pridobivanje
naslovov spremeljivk, toda enkrat je ta sestavni del tipa spremenljivke,
drugič pa nastopa kot operator, tako da je vedno možno iz konteksta ugotoviti,
za katerega gre.</p>
</div>
</div>
<div class="section" id="kazalci">
<h2>Kazalci<a class="headerlink" href="#kazalci" title="Permalink to this headline">¶</a></h2>
<p>Kazalci (<em>pointers</em>) izvirajo iz jezika C, predhodnika C++, in so v C-ju edini način, da
spremenimo vrednost parametra znotraj funkcije.
Kazalec na spremenljivko <tt class="docutils literal"><span class="pre">a</span></tt> tipa <tt class="docutils literal"><span class="pre">T</span></tt> je spremenljivka, katere tip se označi z
<tt class="docutils literal"><span class="pre">T*</span></tt> in njena vrednost pa je naslov spremenljivke <tt class="docutils literal"><span class="pre">a</span></tt>.
Primer definicije:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Zgornja koda izpiše nekaj podobnega  <tt class="docutils literal"><span class="pre">0x7ffe78a6f354</span></tt>, saj je vrednost
spremenljivke <tt class="docutils literal"><span class="pre">p</span></tt> naslov spremenljivke <tt class="docutils literal"><span class="pre">a</span></tt>. Pravimo, da je spremenljivka <tt class="docutils literal"><span class="pre">p</span></tt>
kazalec na <tt class="docutils literal"><span class="pre">a</span></tt>. Tip <tt class="docutils literal"><span class="pre">int*</span></tt> pomeni, da je vrednost, ki je na naslovu, ki je
shranjen v <tt class="docutils literal"><span class="pre">p</span></tt>, v spominu shranjeno celo število. Ta tip nima direktne
povezave s tem, da je naslov sam po sebi tudi celo število, to je tako ali tako
vedno.</p>
<p>Najosnovnejša operacija na kazalcih je operacija, ki dobi vrednost na nekem naslovu.
Operacija se imenuje <em>value of</em> oz. dereferenca in se ga označi z <tt class="docutils literal"><span class="pre">*</span></tt>.
Z njegovo pomočjo dobimo ali nastavimo vrednost na nekem mestu v spominu.
Primer:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">7.5</span><span class="p">;</span>
<span class="kt">double</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>  <span class="c1">// npr. 0x7ffe78a6f354</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mf">8.5</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Zgornji primer izpiše  <tt class="docutils literal"><span class="pre">7.5</span></tt> in <tt class="docutils literal"><span class="pre">8.5</span></tt>, saj izraz <tt class="docutils literal"><span class="pre">*p</span> <span class="pre">=</span> <span class="pre">8.5</span></tt> na mesto
<tt class="docutils literal"><span class="pre">0x7ffe78a6f354</span></tt> (kjer je spremenljivka <tt class="docutils literal"><span class="pre">a</span></tt>) shrani vrednosti <tt class="docutils literal"><span class="pre">8.5</span></tt>.
Tukaj tudi vidimo, zakaj je dobro vedeti tip, na katerega kazalec kaže. Sama
vrednost <tt class="docutils literal"><span class="pre">0x7ffe78a6f354</span></tt> se namreč nanaša na prvi bajt spomina in
zaradi tipa <tt class="docutils literal"><span class="pre">double</span></tt> vemo, da moramo prebrati še naslednjih 7 in jih
interpretirati kot decimalno število.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Če definiramo več kazalcev na isti vrstici, moramo podobno kot pri referencah znak <tt class="docutils literal"><span class="pre">*</span></tt> ponoviti.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span> <span class="o">*</span><span class="n">r2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span> <span class="o">*</span><span class="n">r3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v3</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">Zgornja koda ustvari tri reference <tt class="docutils literal"><span class="pre">r1,</span> <span class="pre">r2,</span> <span class="pre">r3</span></tt> na spremenljivke <tt class="docutils literal"><span class="pre">v1,</span> <span class="pre">v2,</span>
<span class="pre">v3</span></tt>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Za ustvarjenje kazalcev uporabljamo enak znak <tt class="docutils literal"><span class="pre">*</span></tt> kot za dobivanje vrednosti
na danem naslovu. Toda podobno kot pri referencah je enkrat <tt class="docutils literal"><span class="pre">*</span></tt> sestavni del
tipa spremenljivke, drugič pa nastopa kot operator, tako da je vedno možno iz
konteksta ugotoviti, za katerega gre.</p>
</div>
<p>vrednosti kazalcev so vedno naslovi, ki smo jih dobili iz obstoječe
spremenljivke ali sistema. Ne moremo npr. narediti kar</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="sc">&#39;h&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>da bi na mesto <cite>20`</cite> v spominu napisali znak <tt class="docutils literal"><span class="pre">h</span></tt>. Že preajalnik se bo
pritožil</p>
<div class="highlight-none"><div class="highlight"><pre>a.cpp:2:15: error: invalid conversion from ‘int’ to ‘char*’ [-fpermissive]
   char* p = 20;
             ^~
</pre></div>
</div>
<p>Če pa z eksplicitno pretvorbo to vseeno nastavimo, se program sesuje, saj
najverjetneje do celice 20 nimamo dostopa in dobimo napako <tt class="docutils literal"><span class="pre">[1]</span>&nbsp;&nbsp;&nbsp; <span class="pre">24346</span>
<span class="pre">segmentation</span> <span class="pre">fault</span> <span class="pre">(core</span> <span class="pre">dumped)</span></tt>.</p>
<div class="section" id="null-pointer">
<h3>Null pointer<a class="headerlink" href="#null-pointer" title="Permalink to this headline">¶</a></h3>
<p>Z razliko od referenc kazalci lahko ne kažejo nikamor. To povemo tako, da jim
damo vrednost 0, ki predstavlja naslov <tt class="docutils literal"><span class="pre">0x000000000</span></tt>, za kar imamo direktno
besedo <tt class="docutils literal"><span class="pre">nullptr</span></tt>. Tako lahko naredimo</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</pre></div>
</div>
<p>Če je <tt class="docutils literal"><span class="pre">p</span></tt> ničelni kazalec, je neveljavno pogledati rednost na tem mestu &#8211;
zagotovljeno je, da to vedno povzroči napako.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Nastaviti <tt class="docutils literal"><span class="pre">p</span></tt> na <tt class="docutils literal"><span class="pre">nullptr</span></tt> je drugače, kot pustiti nenastavljenega; v tem
primeru bi bila njegova vrednost nenastavljena in bi bila karkoli je ostalo v
spominu, kjer je bil <tt class="docutils literal"><span class="pre">p</span></tt> ustvarjen.</p>
</div>
</div>
</div>
<div class="section" id="delo-s-spominom">
<h2>Delo s spominom<a class="headerlink" href="#delo-s-spominom" title="Permalink to this headline">¶</a></h2>
<p>Spomin za spremenljivke v programih lahko dobimo na več načinov: pravimo da so
spremenljivke lahko na skladu (<em>stack</em>), ali pa na kopici (<em>heap</em>).
Obstajajo tudi drugi predeli, za npr. statične ali globalne spremenljivke, konstantne
podatke, itd..., s katerimi se zdaj ne bomo ukvarjali. Tako sklad kot
kopica sta dela RAMa, kjer lahko naredimo spremenljivke. Za običajne lokalne
spremenljivke je prostor rezerviran na skladu že med prevajanjem programa
in dostop do njih je ponavadi hitrejši. Če kličemo funkcijo, ki kliče funkcijo,
ki imajo vsaka svoje lokalne spremenljivke, se te nalagajo v spomin po vrsti
ko gremo globlje v klicih in sprostijo, ki se z njih vračajo.</p>
<p>Z razliko od sklada se alokacija na kopici dogaja med tekom programa,
spremenljivke na kopici so nepovezane med seboj, dostop do nje je ponavadi
počasnejši, ima pa mnogo več prostora, ki je omejen le z velikostjo virtualnega
spomina, ki je na voljo programu (beri: z velikostjo RAMa).
Spomin na kopici lahko zahtevamo od operacijskega sistema, ga poljubno
uporabljamo in lepo je, da ga na koncu tudi vrnemo.
V C-ju imamo za alokacijo in dealokacijo na voljo para funkcij <tt class="docutils literal"><span class="pre">malloc</span></tt> (<em>memory
allocation</em>) in <tt class="docutils literal"><span class="pre">free</span></tt> (in še nekaj drugih), v C++-u pa sta nadomeščeni z operatorji
<tt class="docutils literal"><span class="pre">new</span></tt>, <tt class="docutils literal"><span class="pre">new[]</span></tt>, <tt class="docutils literal"><span class="pre">delete</span></tt> in <tt class="docutils literal"><span class="pre">delete[]</span></tt>.
Verziji z <tt class="docutils literal"><span class="pre">[]</span></tt> sta namenjeni alokaciji tabel in se bomo z njimi ukvarjali
pozneje. Alokaciji spomina na kopici se pogosto reče tudi <em>dinamična alokacija</em>.</p>
<p>Alokacija spomina vrne kazalec na mesto v RAMu, kjer nam je bi dodeljen prostor
za spremenljivko. Če je bila alokacija neuspešna (npr. zmanjkalo nam je
spomina), C++ vrže izjemo tipa <tt class="docutils literal"><span class="pre">std::bad_alloc</span></tt>. Obstaja več verzij operatorja
<tt class="docutils literal"><span class="pre">new</span></tt>, ki spomin alocirajo na različne načine, npr. brez metanja izjem,
na že določeno mesto, ali pa brez konstrukcije alociranega objekta, toda tudi v
to se ne bomo spuščali.</p>
<p>Primer običaje alokacije decimalnega števila:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mf">2.3</span><span class="p">);</span>  <span class="c1">// p ima vrednost 2.3</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">();</span>     <span class="c1">// q ima vrednost 0.0</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">;</span>       <span class="c1">// r ima nedefinirano vrednost</span>
    <span class="c1">// uporabljamo p, q, r</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// vrnemo spomin sistemu</span>
    <span class="k">delete</span> <span class="n">q</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Vsaki alokaciji mora, ko spomin nehamo uporabljati, slediti dealokacija spomina,
ki jo sprožimo z <tt class="docutils literal"><span class="pre">delete</span></tt>. Tukaj se držimo enostavnega pravila: vsak
poklicani <tt class="docutils literal"><span class="pre">new</span></tt> mora imeni natanko en pripadajoči <tt class="docutils literal"><span class="pre">delete</span></tt>, ki izbriše
spomin, dobljen s tem klicem <tt class="docutils literal"><span class="pre">new</span></tt>.
Čeprav morda sintaksa <tt class="docutils literal"><span class="pre">delete</span> <span class="pre">p</span></tt> izgleda, kot da bi izbrisali spremenljivko
<tt class="docutils literal"><span class="pre">p</span></tt>, izbrišemo samo <em>spomin</em> na katerega <tt class="docutils literal"><span class="pre">p</span></tt> kaže, <tt class="docutils literal"><span class="pre">p</span></tt> pa ostane veljavna
in ji lahko damo neko novo vrednost (vanjo shranimo nek drug naslov). Ko
govorimo, pa se pogosto reče, da smo zbrisali <tt class="docutils literal"><span class="pre">p</span></tt> in se razume, da v resnimi
mislimo spomin na naslovu, shranjenem v <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<p>Preden ga izbrišemo, lahko <tt class="docutils literal"><span class="pre">p</span></tt>, <tt class="docutils literal"><span class="pre">q</span></tt> ali <tt class="docutils literal"><span class="pre">r</span></tt> uporabljamo kot vsak drug kazalec,
npr. nastavimo <tt class="docutils literal"><span class="pre">*p</span> <span class="pre">=</span> <span class="pre">4.2</span></tt>. Tako na roko kot zgoraj v C++ redko alociramo
spremenljivke, saj ponavadi uporabimo mehanizme, ki to počnejo namesto nas in
pri katerih se ne more zgoditi, da bi po nesreči pozabili poklicati <tt class="docutils literal"><span class="pre">delete</span></tt>.
Prav tako pa ne smemo <tt class="docutils literal"><span class="pre">delete</span></tt> poklicati dvakrat. Primer, ko se nam to lahko
zgodi:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pri klicu <tt class="docutils literal"><span class="pre">delete</span> <span class="pre">a</span></tt> se izbriše objekt na naslovu, shranjenemu v <tt class="docutils literal"><span class="pre">a</span></tt>.
Toda spremenljivka <tt class="docutils literal"><span class="pre">b</span></tt> kaže na enak naslov, in ko pokličemo <tt class="docutils literal"><span class="pre">delete</span> <span class="pre">b</span></tt>
sistem zopet poskuša izbrisati že izbrisan objekt na istem naslovu.
Kaj se ob tem zgodi ni definirano (<em>undefined behviour</em>), kar pomeni, da se ne
moremo zanašati na kakršnokoli deterministično obnašanje programa.
Lahko ni narobe nič, lahko se šele kasneje pokaže, da je šlo s spominom nekaj
narobe, lahko se program takoj sesuje. Najpogostejša napaka zgleda podobno</p>
<div class="highlight-none"><div class="highlight"><pre>[1]    26815 segmentation fault (core dumped)  ./a
</pre></div>
</div>
<p>ali pa malo bolj informativno</p>
<div class="highlight-none"><div class="highlight"><pre>*** glibc detected *** ./a: double free or corruption (fasttop): 0x01600008 ***
======= Backtrace: =========
/lib/libc.so.6[0xb162e2d4]
/lib/libc.so.6(cfree+0x9c)[0xb162287c]
./a[0x01600004]
./a[0x01600008]
======= Memory map: ========
...
</pre></div>
</div>
<div class="section" id="memory-leak">
<h3>Memory leak<a class="headerlink" href="#memory-leak" title="Permalink to this headline">¶</a></h3>
<p>Ena izmed pogostejših napak pri programiranju v C-ju in C++-u je
memory leak, kar se lahko prevede kot puščanje spomina. Ideja je, da programu
uhaja spomin, podobno kot iz slabo zategnjene vodovodne cevi pušča voda.
To se zgodi, če nekaj spomina od sistema zahtevamo, nanj pozabimo in ga nikoli
ne vrnemo. Če tak program teče dlje časa, porablja in zahteva čedalje več spomina,
in ga nič ne vrača, kar pomeni da ga nam nekoč zmanjka, računalnik začne
delovati zelo počasi in morda operacijski sistem naš program ubije, ali pa
postane tako neodziven, da je potrebno računalnik ponovno zagnati.
Memory leake je pogosto težko zaznati, saj nič zares ne deluje narobe,
samo program se počasi zažira v RAM.</p>
<p>Za preprečitev memory leakov je potrebno zagotoviti, da vsak alociran spomin,
natanko enkrat izbrišemo, oz. povedano na kratko &#8220;vsak <tt class="docutils literal"><span class="pre">new</span></tt> ima svoj
<tt class="docutils literal"><span class="pre">delete</span></tt>&#8221;. To ne pomeni, da moramo v kodi imeti enako število besedic <tt class="docutils literal"><span class="pre">new</span></tt>
in <tt class="docutils literal"><span class="pre">delete</span></tt> ampak da morajo biti poparčkani pomensko.</p>
<p>C++ ima nekaj mehanizmov, da se memory leakom izognemo v širokem loku: najlažje
tako, da sploh ne uporabljamo dinamičnih alokacij direktno, ampak pustimo
standardni knjižnici, v katere pravilnost zaupamo, da to počne namesto nas.</p>
<p>Enostaven primer memory leaka je, da preprosto ne pokličemo <tt class="docutils literal"><span class="pre">delete</span></tt> v kakšnem
od zgodnjih primerov. Poglejmo si zanimivejši primer:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">double</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mf">3.4</span><span class="p">);</span>
    <span class="c1">// uporabljamo d</span>
    <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">(</span><span class="mf">2.7</span><span class="p">);</span>
    <span class="c1">// uporabljamo d</span>
    <span class="k">delete</span> <span class="n">d</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Čeprav smo uporabljali samo <tt class="docutils literal"><span class="pre">d</span></tt> in ga na koncu tudi zbrisali je spomin,
pridobljen s prvim klicem <tt class="docutils literal"><span class="pre">new</span></tt> izgubljen, saj smo njegov naslov, ki je bil
shranjen v <tt class="docutils literal"><span class="pre">p</span></tt> povozili z drugo vrednostjo. Po tem tudi če bi želeli, ne
moremo več sprostiti tega spomina, saj nimamo nobenega načina, da do njega
pridemo. Zaradi tega se je v C programiranju razvil koncept &#8220;lastništva
pointerja&#8221;, kjer se razmišlja o tem kdo je lastnik nekega pointerja, tj., kdo je
odgovoren za njegov izbris, kar postane pomembno predvsem v bolj kompliciranih
programih, kjer pointerje hranimo dlje časa in jih podajamo več funkcijam.</p>
</div>
</div>
<div class="section" id="tabele">
<h2>Tabele<a class="headerlink" href="#tabele" title="Permalink to this headline">¶</a></h2>
<p>V tem razdelku si bomo ogledali ročno alociranje tabel, ki se v modernem
C++ uporablja redko, toda spodobi se, da to pozna vsak C++ programer.
Če potrebujemo tabelo uporabimo <tt class="docutils literal"><span class="pre">vector</span></tt> in C++ poskrbi za nas.</p>
<p>Podobno kot lahko od sistema zahtevamo spomin za eno samo spremenljivko, lahko
zahtevamo od sistema tudi spomin za cel seznam teh spremenljivk.
Za to imamo na voljo operator, ki se imenuje <tt class="docutils literal"><span class="pre">new[]</span></tt>, uporabimo pa ga kot</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">double</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">25</span><span class="p">];</span>
</pre></div>
</div>
<p>kar alocira prostor za 25 decimalnih števil in vrne naslov prvega elementa.
Če alokacija ne uspe (ker nam je npr. zmanjkalo spomina),
<tt class="docutils literal"><span class="pre">new[]</span></tt>, enako kot pri verziji brez <tt class="docutils literal"><span class="pre">[]</span></tt> vrže izjemo.</p>
<p>Prostor za 25 števil lahko gledamo kot tabelo. Ker <tt class="docutils literal"><span class="pre">t</span></tt> kaže na prvi element
ga lahko nastavimo z <tt class="docutils literal"><span class="pre">*t</span> <span class="pre">=</span> <span class="pre">3.14</span></tt>. Sedaj se seveda porodi naravno vprašanje,
kako nastavimo ostale elemente. Izkaže se, da lahko s pointerji računamo, podobno
kot z navadnimi števili. Naj bosta <tt class="docutils literal"><span class="pre">p</span></tt> in <tt class="docutils literal"><span class="pre">q</span></tt> neka kazalca enakega tipa in
<tt class="docutils literal"><span class="pre">a</span></tt> celo število. Izračunamo lahko <tt class="docutils literal"><span class="pre">p+a</span></tt>, <tt class="docutils literal"><span class="pre">p-a</span></tt>, <tt class="docutils literal"><span class="pre">q-p</span></tt>, poleg tega pa
lahko tudi primerjamo <tt class="docutils literal"><span class="pre">p</span> <span class="pre">&lt;</span> <span class="pre">q</span></tt> (in ostale relacije). Naredimo lahko tudi
<tt class="docutils literal"><span class="pre">++p</span></tt> in <tt class="docutils literal"><span class="pre">--p</span></tt> (in postfiksni verziji) in tudi <tt class="docutils literal"><span class="pre">p</span> <span class="pre">+=</span> <span class="pre">a</span></tt> ipd.</p>
<p>Izraz oblike <tt class="docutils literal"><span class="pre">p+a</span></tt> poveča <tt class="docutils literal"><span class="pre">p</span></tt> za <tt class="docutils literal"><span class="pre">a</span></tt> mest. Če <tt class="docutils literal"><span class="pre">p</span></tt> kaže na naslov <tt class="docutils literal"><span class="pre">1654</span></tt>
potem <tt class="docutils literal"><span class="pre">p+3</span></tt> ne kaže nujno na naslov <tt class="docutils literal"><span class="pre">1657</span></tt>, ampak je to odvisno od tipa, na
katerega <tt class="docutils literal"><span class="pre">p</span></tt> kaže. Če je <tt class="docutils literal"><span class="pre">p</span></tt> tipa <tt class="docutils literal"><span class="pre">double*</span></tt>, potem se <tt class="docutils literal"><span class="pre">p</span></tt> poveča za
<tt class="docutils literal"><span class="pre">3*sizeof(double)</span></tt>, tako da preskočimo za 3 cela decimalna števila naprej,
kar ima več smisla, kot da bi skočili za 3 bajte in končali na sredini nekega
števila. Odštevanje števila deluje podobno, razlika med dvema kazalcema pa
pove, koliko sta narazen, merjeno v velikosti tipa na katerega kažeta.
Velja seveda <tt class="docutils literal"><span class="pre">(p+a)</span> <span class="pre">-</span> <span class="pre">p</span> <span class="pre">==</span> <span class="pre">a</span></tt>.</p>
<p>Seštevanje in odštevanje kazalcev je zelo uporabno pri delu s tabelami. Če
<tt class="docutils literal"><span class="pre">t</span></tt> kot zgoraj kaže na začetek tabele, potem <tt class="docutils literal"><span class="pre">t+1</span></tt> kaže na naslednji
element, <tt class="docutils literal"><span class="pre">t+2</span></tt> na tretjega in v splošnem <tt class="docutils literal"><span class="pre">t+i</span></tt> na element na indeksu <tt class="docutils literal"><span class="pre">i</span></tt>.
Če želimo na <tt class="docutils literal"><span class="pre">i</span></tt>-to mesto nekaj napisati, to storimo tako, da izvedemo
<tt class="docutils literal"><span class="pre">*(t+i)</span> <span class="pre">=</span> <span class="pre">-2.34</span></tt>. Ker se izrazi oblike <tt class="docutils literal"><span class="pre">*(t+i)</span></tt> v C++ tako pogosto
pojavljajo, so zanje naredili poseben operator: znani operator <tt class="docutils literal"><span class="pre">[]</span></tt>
za indeksiranje tabel. Po definiciji velja <tt class="docutils literal"><span class="pre">t[i]</span> <span class="pre">==</span> <span class="pre">*(t+i)</span></tt>.
Ta operator nam omogoča da s tabelo <tt class="docutils literal"><span class="pre">t</span></tt> delamo kot ponavadi:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pri tem moramo paziti da ne gremo prek začetka ali konca tabele. C++ sam se
glede tega ne bo nič pritožil, pa tudi pri izvajanju ne pride nujno do napake &#8211;
če gremo preveč preko konca se bo program najbrž sesul s <tt class="docutils literal"><span class="pre">segmentation</span> <span class="pre">fault</span></tt>,
toda če gremo samo malo čez tabelo, pa ne. Toda, po standardu je dostop do
elementov, ki niso del tabele <em>nedefinirano obnašanje</em> (undefined behaviour),
kar pomeni, da nimate nobene garancije kaj se bo zgodilo in se na tako obnašanje
ne morete zanašati: program se lahko sesuje, lahko dobite vrednost 0, lahko
dobite neko navidez naključno številko, lahko se pokvari nek drug del
programa...</p>
<p>Po koncu uporabe moramo tabelo tudi izbrisati z</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">delete</span><span class="p">[]</span> <span class="n">t</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="kako-naredimo-tabelo-ki-se-sama-povecuje">
<h3>Kako naredimo tabelo, ki se sama povečuje<a class="headerlink" href="#kako-naredimo-tabelo-ki-se-sama-povecuje" title="Permalink to this headline">¶</a></h3>
<p>TODO opis.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="c1">// Dve strategiji povečevanja</span>
<span class="k">struct</span> <span class="n">MultiplyByConstantAllocationStrategy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">init_capacity</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">change_capacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">capacity</span> <span class="o">*</span> <span class="mf">1.2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">AddConstantAllocationStrategy</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">init_capacity</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">10</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">change_capacity</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">capacity</span> <span class="o">+</span> <span class="mi">100000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Lastna tabela</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">AllocationStrategy</span><span class="o">=</span><span class="n">MultiplyByConstantAllocationStrategy</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Tabela</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity_</span><span class="p">;</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">t</span><span class="p">;</span>
  <span class="nl">public:</span>
    <span class="n">Tabela</span><span class="p">()</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">capacity_</span><span class="p">(</span><span class="n">AllocationStrategy</span><span class="o">::</span><span class="n">init_capacity</span><span class="p">()),</span>
           <span class="n">t</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity_</span><span class="p">])</span> <span class="p">{}</span>
    <span class="c1">// copy constructor (za kopiranje tabele)</span>
    <span class="n">Tabela</span><span class="p">(</span><span class="k">const</span> <span class="n">Tabela</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size_</span><span class="p">),</span> <span class="n">capacity_</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">capacity_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity_</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// copy assignment (za kopiranje tabele)</span>
    <span class="n">Tabela</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Tabela</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size_</span><span class="p">;</span>
        <span class="n">capacity_</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">capacity_</span><span class="p">;</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity_</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">Tabela</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size_</span> <span class="o">==</span> <span class="n">capacity_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">capacity_</span> <span class="o">=</span> <span class="n">AllocationStrategy</span><span class="o">::</span><span class="n">change_capacity</span><span class="p">(</span><span class="n">capacity_</span><span class="p">);</span>
            <span class="n">T</span><span class="o">*</span> <span class="n">nt</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity_</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">nt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">// skopiramo elemente</span>
            <span class="p">}</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">t</span><span class="p">;</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">nt</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">t</span><span class="p">[</span><span class="n">size_</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Dodamo možnost printanja tabele.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Tabela</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[]&quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* test tabele */</span>
    <span class="n">Tabela</span><span class="o">&lt;</span><span class="n">Tabela</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">({});</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">j</span> <span class="o">%</span> <span class="mi">26</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// cout &lt;&lt; a &lt;&lt; endl;</span>

    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

    <span class="p">{</span>
        <span class="n">Tabela</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">MultiplyByConstantAllocationStrategy</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">clock_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">clock_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="kt">double</span> <span class="n">elapsed_secs</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed_secs</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">Tabela</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">AddConstantAllocationStrategy</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">clock_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">clock_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="kt">double</span> <span class="n">elapsed_secs</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed_secs</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">clock_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">t</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="kt">clock_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
            <span class="kt">double</span> <span class="n">elapsed_secs</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed_secs</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pametni-kazalci-in-reference">
<h2>Pametni kazalci in reference<a class="headerlink" href="#pametni-kazalci-in-reference" title="Permalink to this headline">¶</a></h2>
<p>C++ ima od verzije 11 v knjižnici memory</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="objekti.html" class="btn btn-neutral float-right" title="Objekti"/>Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="funkcije.html" class="btn btn-neutral" title="Funkcije"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014–2019, Natan Žabkar, Jure Slak, Maks Kolman, Ines Meršak.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>